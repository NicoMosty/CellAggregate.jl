include("forces/forces_func.jl")

"""
# AdaptStruct

Iterates over subtypes of ForceType and applies the CUDA adaptation macro to each subtype, generating a 
specialized force function for one set of parameters.

## Note:
• The code assumes that the abstract type `ForceType` has been defined, and that `Cubic{T}` is a concrete 
  subtype of it.
• It uses the `subtypes` function to obtain all subtypes of `ForceType`, which in this case includes only `Cubic{T}`.
• For each subtype `j`, the code applies the CUDA adaptation macro `Adapt.@adapt_structure` to the corresponding 
  type definition, which generates code that allows instances of that type to be used with CUDA.
• The code then generates a specialized version of the `force_func` function sfor each subtype `j`, by setting the 
  second argument of the generic `force_func` to 1. This is useful for optimizing the performance of the function.

## Example usage:

* Define abstract type and subtype

julia> Base.@kwdef struct Cubic{T} <: ForceType
           μ₁ :: T; rₘᵢₙ :: T; rₘₐₓ :: T
       end


* Apply CUDA adaptation and generate specialized force function

julia> Adapt.@adapt_structure(Cubic)

julia> force_func(p::Cubic,value) = force_func(p::Cubic,1,value)
force_func (generic function with 3 methods)

"""
function AdaptStruct(forcetype)
    for j = subtypes(forcetype)
    # Adapt Force Struct for CUDA
    eval(Meta.parse("Adapt.@adapt_structure($(j))"))
    # Generate fonce_func for one set of parameters
    eval(Meta.parse("force_func(p::$(j),value) = force_func(p::$(j),1,value)"))
    end
end
AdaptStruct(ForceType)

"""
# Specific type of data from float or CuArray 

Two type aliases, `CuOrFloat` and `CuOrInt`, which are unions of CUDA arrays and primitive Julia types.

`CuOrFloat` is a union of `CuArray` and `Float64`, and is commonly used to indicate that a function or method
            can accept either a CUDA array or a regular floating-point number.

`CuOrInt` is a union of `CuArray` and `Int64`, and is similarly used to indicate that a function or method 
          can accept either a CUDA array or a regular integer.

## Example usage:

*  Define a function that accepts a CuOrFloat argument

julia> function compute_square(x::CuOrFloat)
           if isa(x, CuArray)
               return CUDA.@. x^2 # apply elementwise squaring to the CUDA array
           else
               return x^2 # compute the square of the regular floating-point number
           end
       end
compute_square (generic function with 1 method)

* Call the function with a CUDA array and a regular numbers

julia> x_cu = CUDA.rand(3, 3)
3×3 CuArray{Float32, 2, CUDA.Mem.DeviceBuffer}:
 0.162578   0.516164  0.876415
 0.0713731  0.362075  0.43124
 0.171495   0.68116   0.115033

x_flt = 2.5

julia> result_cu = compute_square(x_cu) 
3×3 CuArray{Float32, 2, CUDA.Mem.DeviceBuffer}:
 0.0264315   0.266425  0.768103
 0.00509413  0.131099  0.185968
 0.0294106   0.463978  0.0132325


julia> compute_square(x_flt)
6.25

"""
CuOrFloat,  CuOrInt= Union{CuArray, Float64}, Union{CuArray, Int64}

 #================================== STRUCT PARAMETERS ====================================#
"""
# Interaction Parameters Struct

Two mutable structs, `ContractilePar` and `InteractionPar`, that are used to represent 
parameters of a physical simulation.

`ContractilePar` is a mutable struct that contains a single field `fₚ`, which represents the force 
                 generated by a contractile element.

`InteractionPar` is a mutable struct that contains two fields:
- `Force`, which is of abstract type `ForceType`, and represents the type of force that is being simulated.
- `Contractile`, which is a `ContractilePar` object, and represents the contractile parameters of the simulation.

Both structs are defined using the `@kwdef` macro, which allows for keyword-based construction of the structs.

## Example usage:

* Define an abstract type and its subtypes

julia> abstract type ForceType end
julia> mutable struct Cubic <: ForceType end

* Create a ContractilePar object   

julia> contractile_par = ContractilePar(fₚ=2.5)
ContractilePar(2.5)

* Create an InteractionPar struct with a Gravity force and the above contractile parameters

julia> interaction_par = InteractionPar(Force=Cubic(), Contractile=contractile_par)
InteractionPar(Cubic(), ContractilePar(2.5))

* Access the fields of the InteractionPar struct  

julia> interaction_par.Force
Cubic()

julia> interaction_par.Contractile.fₚ
2.5

"""
Base.@kwdef mutable struct ContractilePar
    fₚ           
end
Base.@kwdef mutable struct InteractionPar
    Force        :: ForceType
    Contractile  :: ContractilePar
end

"""
# Model Parameters

`TimeModel` is a mutable struct that stores simulation time parameters.
It has the following fields:

  • `tₛᵢₘ`  : Float64 : minimum time of the simulation.
  • `dt`    : Float64 : time increment between each step.
  • `nₖₙₙ`  : Int64 : number of steps to be taken in the nearest neighbor calculation.
  • `nₛₐᵥₑ` : Int64 : number of steps to be skipped before saving simulation data.

---

`InputModel` is a mutable struct that stores simulation input parameters.
It has the following fields:

  • `outer_ratio` : Float64 : defines how many radio outside of the particle layer to separate the 
                              data inside an aggregate.
  • `path_input`  : String : path of the input file containing particle data.

---

`ModelSet` is a mutable struct that stores the models used for the simulation.
It has the following fields:

  • `Time`  : a `TimeModel` object containing simulation time parameters.
  • `Input` : an `InputModel` object containing simulation input parameters.

"""
Base.@kwdef mutable struct TimeModel
    tₛᵢₘ        :: Float64
    dt          :: Float64
    nₖₙₙ        :: Int64
    nₛₐᵥₑ       :: Int64
end 
Base.@kwdef mutable struct InputModel
    outer_ratio     :: Float64
    path_input      :: String
end 
Base.@kwdef mutable struct OutputModel
    name_output      :: String
    path_output      :: String
end 
Base.@kwdef mutable struct ModelSet
    Time        :: TimeModel
    Input       :: InputModel
    Output
end


#================================= Aggregate Parameters =======================================#
# """
# `AggMatrix` is a mutable struct definition for an aggregate matrix.
#     It has the following fields:
    
#       • `Type`     : Type of the aggregate.
#       • `Property` : Property of the aggregate.
#       • `rₘₐₓ`     : Maximum radius of interaction (cutoff) for the aggregate.
    
# ---
# """
# Base.@kwdef mutable struct AggMatrix
#     Type       
#     Property 
#     rₘₐₓ
# end
"""
`AggType` is a mutable struct definition for specific aggregate type taking this name, 
parameters `Interaction` and position of each cell on the aggregate.

    It has the following fields:
    
      • `Type`     : Type of the aggregate.
      • `Property` : Property of the aggregate.
      • `rₘₐₓ`     : Maximum radius of interaction (cutoff) for the aggregate.
    
      This struct also has a constructor function called AggType that takes 
      three arguments: name, interaction, and position. The function sets the 
      Type field to the type of the position argument, converts position to a 
      matrix, calculates the radius of the aggregate using the find_radius function, 
      and creates and returns a new AggType object with the given name, interaction, 
      radius, position, and Type.
---
"""
Base.@kwdef mutable struct AggType
    Name        :: String
    Interaction :: InteractionPar
    Radius
    Position
    Type
    function AggType(name, interaction,position)
        type = typeof(position)
        position = Matrix(position)
        radius = find_radius(position)
        new(name,interaction, radius, position, type)
    end
end

"""
The AggLocation struct represents the location of each aggregate 
    
    It has the following fields:

        • `Name``     : A string containing the name of the aggregate.
        • `Location`` : The position of the aggregate.
---
"""
Base.@kwdef mutable struct AggLocation
    Name :: String
    Location
end

"""
The AggLocation struct represents the index of each cell on the aggregate for the next fields 
    
    It has the following fields:

        • `Type``     : A string containing a type of aggregation.
        • `Agg``      : An aggregation instance for the index.
        • `Name``     : A string name for this aggregation.
---
"""
Base.@kwdef mutable struct AggIndex
    Type
    Agg
    Name
end
"""
The AggGeometry mutable struct represents the geometric properties of an aggregate.

    It has the following fields:

        • `radius_agg``   : The radius of the aggregate.
        • `outline``      : The outline of the aggregate, which could be an array of points or any other 
                            geometric representation of the aggregate.
---
"""
Base.@kwdef mutable struct AggGeometry
    radius_agg
    outline
end
"""
The AggParameter structure holds force, contractile and radius properties of an aggregate.

    It has the following fields:

        • `Force``       : The force parameters represented as an struct of arrays on ForceType defined previewed.
        • `Contractile`` : The force parameters represented as an struct of arrays on ContractilePar defined previewed.
        • `Radius``      : An array of the radius of the aggregate which each cell belongs.
---

The AggNeighbor structure holds neighbor indices and contact indices of an aggregate.

    It has the following fields:

        • `idx``      : Distance matrix index of each cell on the aggregate cutted with the maximum radius (rₘₐₓ).
        • `idx_red`   : Reduced Distance matrix deleting zero values.
        • `idx_sum`   : Sum of the data on each column in idx_red.
        • `idx_cont`  : Index matrix flitered with idx_red with a random calculation cutting on a max row size.
---

The AggForce structure holds force and displacement properties of an aggregate.
    
It has the following fields:

        • `F``   : Calculus of the displacement force of each cell on the aggregate.
        • `dX`   : Reduced Distance matrix deleting zero values.
---

The AggSimulation structure holds AggParameter, AggNeighbor and AggForce structures, which are used to simulate and analyze aggregate behavior.
"""
Base.@kwdef mutable struct AggParameter
    Force
    Contractile
    Radius
end
Base.@kwdef mutable struct AggNeighbor       
    idx_red 
    dist   
    idx_sum     
    idx_cont  
end
Base.@kwdef mutable struct AggForce
    Pol
    F
    dX
end

Base.@kwdef mutable struct AggSimulation
    Parameter :: AggParameter
    Neighbor  :: AggNeighbor
    Force     :: AggForce
end

"""
This is the docstring for the Aggregate mutable struct. It defines a container for information about a 
collection of aggregates in a simulation. 

    The struct has several fields:

        • Type       : The type of the aggregate, which is a collection of similar aggregates
        • Index      : The index of the aggregate, which is used to identify the aggregate
        • Position   : The position of the aggregate
        • Geometry   : The geometry of the aggregate, including its radius and outline
        • Simulation : The simulation parameters for the aggregate

    The struct also has a constructor function, Aggregate, that takes three arguments:

        • agg_type : A list of aggregate types
        • location : The location of each aggregate
        • model    : A simulation model that contains various parameters

The function filters and extracts different properties of each aggregate by its location. It then calculates 
the aggregate geometry, index, and simulation parameters, before finally creating and returning a new 
Aggregate object.
"""
Base.@kwdef mutable struct Aggregate
    Type  
    Index
    Position
    Geometry
    Simulation

    function Aggregate(agg_type, location, model)

        # Extract the type of data used on the aggregate (GPU or CPU)
        data_type = unique([agg_type[i].Type for i=1:size(agg_type,1)])[1]
        # Extract the type of ForceType used on the aggregate
        force_type = eval(nameof(unique([typeof(agg_type[i].Interaction.Force) for i=1:size(agg_type,1)])[1]))

        """
        # Filtering differents properties by the location
        The constructor first extracts various properties from agg_type that correspond to the given location. 
        It then computes the position, radius, and geometry of the aggregate based on these extracted properties. 
        The Index field is set based on the Type and Name properties of the aggregate at the given location.
        """
        pos_loc = filter_prop(agg_type,location,"Position")
        radius_loc = filter_prop(agg_type,location,"Radius")
        type_loc = index_prop(agg_type,location)
        name_loc = filter_prop(agg_type,location,"Name")
        interaction_loc = filter_prop(agg_type,location,"Interaction")
        force_loc = getproperty.(interaction_loc, :Force)
        contractile_loc = getproperty.(interaction_loc, :Contractile)
        loc = getproperty.(location,:Location)

        # Joining position of each aggregate according to the pos_loc calculation
        pos = vcat(pos_loc...)
        # Joining aggregate radius of each cell according to the pos_loc calculation
        radius = repeat_prop(pos_loc, radius_loc)
        """
        # Geometry
        This code defines a constructor for an AggGeometry struct with two fields: radius_agg and outline.

            • The radius_agg field is assigned the value of the radius argument. 

            • The outline field is created by computing a Boolean array where each element represents whether or not the 
            corresponding aggregate is on the boundary of the simulation domain. This is determined by checking whether the 
            Euclidean distance between the aggregate position and any of the simulation domain edges is greater than the product 
            of the radius and the outer_ratio input parameter of the simulation model. If the distance is greater, the corresponding 
            element of the outline array is set to 1, indicating that the aggregate is on the boundary. Otherwise, the element is set to 0.
        ---
        """
        geometry = AggGeometry(
            radius,
            ifelse.(
                [euclidean(pos,i) for i=1:size(pos,1)] .> radius*model.Input.outer_ratio,
                1,2
            )
        )
        """
        # index
        This code initializes an AggIndex struct with three fields:

            • idx_type: a GPUArray containing the types of the aggregates, with one element for each aggregate in the pos_loc list.
            • idx: a GPUArray containing the indices of the aggregates, with one element for each aggregate in the pos_loc list.
            • name: a list of strings containing the names of the aggregates in the pos_loc list.
        
        The values for each field are obtained by applying some functions (CPUtoGPU, Int., repeat_prop) to the input pos_loc, type_loc, and name_loc lists.
        
        The CPUtoGPU function converts an array from CPU memory to GPU memory, which is used for faster processing on a GPU. 
            The Int. function converts the array elements to integers. The repeat_prop function repeats each element of a list by a given number of 
            times and returns a flattened array of the results.
        
        The AggIndex struct seems to be used for keeping track of the properties of the aggregates, such as their type, index, and name, and is 
        likely used in later processing steps.
        """
        index = AggIndex(
            CPUtoGPU(data_type,Int.(repeat_prop(pos_loc, type_loc))),
            CPUtoGPU(data_type,Int.(repeat_prop(pos_loc))),
            repeat_prop(pos_loc, name_loc)
        )

        """
        This line of code creates a move vector to be added to the pos positions of the aggregate. It concatenates the repeated loc values based on the size 
        of each location, so that each particle in a location is moved by the same amount. The resulting move vector has the same dimensions as the pos vector, 
        and will be added to it element-wise.

        This is used to move each aggregate according to the location parameter

        At the last the position calculations is converted to CuArray if int required
        """
        move = vcat([vcat(repeat(loc[i,:], inner=(1,size.(filter_prop(agg_type,location,"Position"),1)[i]))...) for i=1:size(loc,1)]...)
        pos = CPUtoGPU(data_type,pos+move)

        """
        This line of code calculates the maximum value of the r_max attribute of the Force object of each element in the Interaction field of each element in the agg_type input. 
        The getproperty function is used to access the Force field of each Interaction object, and then the r_max field of each Force object is accessed using the dot syntax ".". 
        Finally, the max function is used to calculate the maximum value of all r_max values.
        """
        max_rₘₐₓ = max([getproperty.(agg_type, :Interaction)[i].Force.rₘₐₓ for i=1:size(agg_type,1)]...)

        """
        Calculates the size of the reduced index based on the maximum interaction radius of the particles in the aggregation system.

        Args:
            max_rₘₐₓ (float): Maximum interaction radius among all particles in the aggregation system.
        
        Returns:
            int: Size of the reduced index.
        """

        # idx_red_size =  max_rₘₐₓ ≤ 2.80 ? 20 :
        #         2.80 < max_rₘₐₓ ≤ 3.45 ? 25 :
        #         3.45 < max_rₘₐₓ ≤ 3.80 ? 40 :
        #         3.80 < max_rₘₐₓ ≤ 4.00 ? 60 :
        #         4.00 < max_rₘₐₓ ≤ 5.00 ? 80 :
        #         5.0 < max_rₘₐₓ ≤ 7.00 ? 200 :
        #         size(pos,1)/2
        idx_red_size = 1000

        """
        # agg_parameter
        This code defines a function or method that takes in several input arguments and returns an instance of 
        AggParameter. Here is the docstring:
        
            The struct has several fields:
        
                • `force_type`      : Type  : Type of force to use in simulation
                • `location`        : Array : Array of aggregates to apply parameters to
                • `pos_loc`         : Array : Array of positions for aggregates
                • `contractile_loc` : Array : Array of contractile parameters for aggregates
                • `agg_type`        : Array : Array of aggregate types

        ## Returns
        
        agg_parameter : AggParameter
            Instance of AggParameter class

        The function creates an instance of AggParameter by calling its constructor and passing in the following arguments:

            • A call to CPUtoGPU function that takes in a variadic list of arguments. Each argument is a call to repeat_prop 
              function that takes in the pos_loc array and an array of properties of the corresponding type in location array. 
              The CPUtoGPU function returns an array of GPUArray objects.

            • A call to CPUtoGPU function that takes in an array of contractile parameters and returns a GPUArray object.

            • A call to CPUtoGPU function that takes in an array of radii of the aggregates and returns a GPUArray object.
        
        Finally, the function returns the instance of AggParameter.
        
        """
        agg_parameter = AggParameter(
            force_type(
                    [
                    CPUtoGPU(data_type,repeat_prop(
                        pos_loc,
                        [getproperty(force_loc[i],fieldnames(force_type)[j]) 
                            for i=1:size(location,1)]
                    ))
                    for j=1:size(fieldnames(force_type),1)
                ]...
            ),
            ContractilePar(
                CPUtoGPU(
                    data_type,
                    repeat_prop(pos_loc,[getproperty(contractile_loc[i],:fₚ) for i=1:size(location,1)])
                )
            ),
            CPUtoGPU(data_type,vcat([agg_type[i].Radius' for i=1:size(agg_type,1)]...))
        )

        """
        # neighbor_cell
        This function creates an AggNeighbor object with four attributes:

            The struct has several fields:

                • `idx`    : A 2D array of integers of size (n, n) where n is the number of particles. 
                    Each row represents a particle and contains the indices of its neighboring particles.

                • `idx_red`: A 2D array of integers of size (idx_red_size, n) where n is the number of particles and 
                             idx_red_size is a size determined by the max_rₘₐₓ parameter. This attribute is used to 
                              speed up the neighbor search by considering only a subset of the neighboring particles.

                • `idx_sum`: A 1D array of integers of size n representing the cumulative sum of the number of neighbors for each particle.

                • `idx_cont`: A 2D array of integers of size (model.Time.nₖₙₙ, n) where n is the number of particles and model.Time.nₖₙₙ is 
                              the number of time steps. This attribute is used to store the indices of the contacting neighbors at each time step.
        """
        neighbor_cell = AggNeighbor(
            idx_red  = CPUtoGPU(data_type, Int32.(zeros(idx_red_size, size(pos,1)))),
            dist     = CPUtoGPU(data_type, zeros(idx_red_size, size(pos,1))),
            idx_sum  = CPUtoGPU(data_type, Int32.(zeros(1,size(pos,1)))),
            idx_cont = CPUtoGPU(data_type, Int32.(zeros(model.Time.nₖₙₙ,size(pos,1))))
        )

        """
        # AggForce
        Create an `AggForce` object representing the force acting on particles in the simulation. The `dX` and `F` fields are initialized as arrays 
        of zeros with the same dimensions as the `pos` array, which is assumed to be a 2D array representing the positions of particles in the simulation.

            The struct has several fields:
                
                • `pos`: a 2D array representing the positions of particles in the simulation.
                • `T`: the element type of the `dX` and `F` arrays. Default is `Float64`.
        """
        force_cell = AggForce(
            dX       = CPUtoGPU(data_type, zeros(size(pos))),
            F        = CPUtoGPU(data_type, zeros(size(pos))),
            Pol      = CPUtoGPU(data_type, zeros(size(pos))) 
        )
        simulation = AggSimulation(agg_parameter, neighbor_cell,force_cell)

        new(agg_type,index, pos, geometry, simulation)
    end
end

# Adding Aggregates Functions
include("functions/aggregate_functions.jl")